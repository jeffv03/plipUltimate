
bin\Debug\avr-bootloader.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003d6  00007000  00007000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000081  00800100  00800100  0000044a  2**0
                  ALLOC
  2 .debug_aranges 00000020  00000000  00000000  0000044a  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 00000093  00000000  00000000  0000046a  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000004a4  00000000  00000000  000004fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000001a6  00000000  00000000  000009a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000466  00000000  00000000  00000b47  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000070  00000000  00000000  00000fb0  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    000001a1  00000000  00000000  00001020  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000024e  00000000  00000000  000011c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000150  00000000  00000000  0000140f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	0c 94 34 38 	jmp	0x7068	; 0x7068 <__ctors_end>
    7004:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7008:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    700c:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7010:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7014:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7018:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    701c:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7020:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7024:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7028:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    702c:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7030:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7034:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7038:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    703c:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7040:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7044:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7048:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    704c:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7050:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7054:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7058:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    705c:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7060:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7064:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>

00007068 <__ctors_end>:
    7068:	11 24       	eor	r1, r1
    706a:	1f be       	out	0x3f, r1	; 63
    706c:	cf ef       	ldi	r28, 0xFF	; 255
    706e:	d8 e0       	ldi	r29, 0x08	; 8
    7070:	de bf       	out	0x3e, r29	; 62
    7072:	cd bf       	out	0x3d, r28	; 61

00007074 <__do_clear_bss>:
    7074:	11 e0       	ldi	r17, 0x01	; 1
    7076:	a0 e0       	ldi	r26, 0x00	; 0
    7078:	b1 e0       	ldi	r27, 0x01	; 1
    707a:	01 c0       	rjmp	.+2      	; 0x707e <.do_clear_bss_start>

0000707c <.do_clear_bss_loop>:
    707c:	1d 92       	st	X+, r1

0000707e <.do_clear_bss_start>:
    707e:	a1 38       	cpi	r26, 0x81	; 129
    7080:	b1 07       	cpc	r27, r17
    7082:	e1 f7       	brne	.-8      	; 0x707c <.do_clear_bss_loop>
    7084:	0e 94 60 39 	call	0x72c0	; 0x72c0 <main>
    7088:	0c 94 e9 39 	jmp	0x73d2	; 0x73d2 <_exit>

0000708c <__bad_interrupt>:
    708c:	0c 94 00 38 	jmp	0x7000	; 0x7000 <__vectors>

00007090 <waitForStatusPin>:
 * Waits approximately 2s for given status pin value.
 * @param ubStatusPin Pin number to monitor.
 * @param ubValue     Desired pin value. 1 for high, 0 for low.
 * @return 1 if monitored pin reaches its desired state, otherwise 0.
 */
uint8_t waitForStatusPin(uint8_t ubStatusPin, uint8_t ubValue) {
    7090:	a8 2f       	mov	r26, r24
    7092:	20 e0       	ldi	r18, 0x00	; 0
    7094:	30 e0       	ldi	r19, 0x00	; 0
	uint16_t uwCounter = 0;
	while(uwCounter < 20000) {
		if(((PAR_STATUS_PIN >> ubStatusPin) & 1) == ubValue)
    7096:	e6 e2       	ldi	r30, 0x26	; 38
    7098:	f0 e0       	ldi	r31, 0x00	; 0
    709a:	70 e0       	ldi	r23, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    709c:	44 ef       	ldi	r20, 0xF4	; 244
    709e:	51 e0       	ldi	r21, 0x01	; 1
    70a0:	80 81       	ld	r24, Z
    70a2:	90 e0       	ldi	r25, 0x00	; 0
    70a4:	0a 2e       	mov	r0, r26
    70a6:	02 c0       	rjmp	.+4      	; 0x70ac <waitForStatusPin+0x1c>
    70a8:	95 95       	asr	r25
    70aa:	87 95       	ror	r24
    70ac:	0a 94       	dec	r0
    70ae:	e2 f7       	brpl	.-8      	; 0x70a8 <waitForStatusPin+0x18>
    70b0:	81 70       	andi	r24, 0x01	; 1
    70b2:	90 70       	andi	r25, 0x00	; 0
    70b4:	86 17       	cp	r24, r22
    70b6:	97 07       	cpc	r25, r23
    70b8:	11 f4       	brne	.+4      	; 0x70be <waitForStatusPin+0x2e>
    70ba:	81 e0       	ldi	r24, 0x01	; 1
    70bc:	08 95       	ret
			return 1;
		++uwCounter;
    70be:	2f 5f       	subi	r18, 0xFF	; 255
    70c0:	3f 4f       	sbci	r19, 0xFF	; 255
    70c2:	ca 01       	movw	r24, r20
    70c4:	01 97       	sbiw	r24, 0x01	; 1
    70c6:	f1 f7       	brne	.-4      	; 0x70c4 <waitForStatusPin+0x34>
 * @param ubValue     Desired pin value. 1 for high, 0 for low.
 * @return 1 if monitored pin reaches its desired state, otherwise 0.
 */
uint8_t waitForStatusPin(uint8_t ubStatusPin, uint8_t ubValue) {
	uint16_t uwCounter = 0;
	while(uwCounter < 20000) {
    70c8:	8e e4       	ldi	r24, 0x4E	; 78
    70ca:	20 32       	cpi	r18, 0x20	; 32
    70cc:	38 07       	cpc	r19, r24
    70ce:	41 f7       	brne	.-48     	; 0x70a0 <waitForStatusPin+0x10>
    70d0:	80 e0       	ldi	r24, 0x00	; 0
			return 1;
		++uwCounter;
		_delay_us(100);
	}
	return 0;
}
    70d2:	08 95       	ret

000070d4 <blink>:
 * Blinks status LED a given number of times.
 * Each blink takes 1 second. A series of blinks is preceeded and followed by
 * 1 second of low state.
 * @param ubCount Blink count.
 */
void blink(uint8_t ubCount) {
    70d4:	68 2f       	mov	r22, r24
	LED_PORT &= ~LED_STATUS;
    70d6:	e8 e2       	ldi	r30, 0x28	; 40
    70d8:	f0 e0       	ldi	r31, 0x00	; 0
    70da:	80 81       	ld	r24, Z
    70dc:	8f 7d       	andi	r24, 0xDF	; 223
    70de:	80 83       	st	Z, r24
    70e0:	20 e1       	ldi	r18, 0x10	; 16
    70e2:	37 e2       	ldi	r19, 0x27	; 39
    70e4:	44 ef       	ldi	r20, 0xF4	; 244
    70e6:	51 e0       	ldi	r21, 0x01	; 1
    70e8:	ca 01       	movw	r24, r20
    70ea:	01 97       	sbiw	r24, 0x01	; 1
    70ec:	f1 f7       	brne	.-4      	; 0x70ea <blink+0x16>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    70ee:	21 50       	subi	r18, 0x01	; 1
    70f0:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    70f2:	d1 f7       	brne	.-12     	; 0x70e8 <blink+0x14>
    70f4:	16 c0       	rjmp	.+44     	; 0x7122 <blink+0x4e>
	_delay_ms(1000);
	while(ubCount--) {
		LED_PORT |= LED_STATUS;
    70f6:	80 81       	ld	r24, Z
    70f8:	80 62       	ori	r24, 0x20	; 32
    70fa:	80 83       	st	Z, r24
    70fc:	9d 01       	movw	r18, r26
    70fe:	ca 01       	movw	r24, r20
    7100:	01 97       	sbiw	r24, 0x01	; 1
    7102:	f1 f7       	brne	.-4      	; 0x7100 <blink+0x2c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7104:	21 50       	subi	r18, 0x01	; 1
    7106:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7108:	d1 f7       	brne	.-12     	; 0x70fe <blink+0x2a>
		_delay_ms(500);
		LED_PORT &= ~LED_STATUS;
    710a:	80 81       	ld	r24, Z
    710c:	8f 7d       	andi	r24, 0xDF	; 223
    710e:	80 83       	st	Z, r24
    7110:	9d 01       	movw	r18, r26
    7112:	ca 01       	movw	r24, r20
    7114:	01 97       	sbiw	r24, 0x01	; 1
    7116:	f1 f7       	brne	.-4      	; 0x7114 <blink+0x40>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7118:	21 50       	subi	r18, 0x01	; 1
    711a:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    711c:	d1 f7       	brne	.-12     	; 0x7112 <blink+0x3e>
    711e:	61 50       	subi	r22, 0x01	; 1
    7120:	06 c0       	rjmp	.+12     	; 0x712e <blink+0x5a>
 */
void blink(uint8_t ubCount) {
	LED_PORT &= ~LED_STATUS;
	_delay_ms(1000);
	while(ubCount--) {
		LED_PORT |= LED_STATUS;
    7122:	e8 e2       	ldi	r30, 0x28	; 40
    7124:	f0 e0       	ldi	r31, 0x00	; 0
    7126:	a8 e8       	ldi	r26, 0x88	; 136
    7128:	b3 e1       	ldi	r27, 0x13	; 19
    712a:	44 ef       	ldi	r20, 0xF4	; 244
    712c:	51 e0       	ldi	r21, 0x01	; 1
 * @param ubCount Blink count.
 */
void blink(uint8_t ubCount) {
	LED_PORT &= ~LED_STATUS;
	_delay_ms(1000);
	while(ubCount--) {
    712e:	66 23       	and	r22, r22
    7130:	11 f7       	brne	.-60     	; 0x70f6 <blink+0x22>
    7132:	20 e1       	ldi	r18, 0x10	; 16
    7134:	37 e2       	ldi	r19, 0x27	; 39
    7136:	44 ef       	ldi	r20, 0xF4	; 244
    7138:	51 e0       	ldi	r21, 0x01	; 1
    713a:	ca 01       	movw	r24, r20
    713c:	01 97       	sbiw	r24, 0x01	; 1
    713e:	f1 f7       	brne	.-4      	; 0x713c <blink+0x68>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7140:	21 50       	subi	r18, 0x01	; 1
    7142:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7144:	d1 f7       	brne	.-12     	; 0x713a <blink+0x66>
		_delay_ms(500);
		LED_PORT &= ~LED_STATUS;
		_delay_ms(500);
	}
	_delay_ms(1000);
}
    7146:	08 95       	ret

00007148 <bootExit>:
/**
 * Exits bootloader with given result code.
 * Result code is indicated by status LED.
 * @param ubCode Result code.
 */
void bootExit(uint8_t ubCode) {
    7148:	0f 93       	push	r16
    714a:	1f 93       	push	r17
	LED_DDR |= LED_STATUS;
    714c:	07 e2       	ldi	r16, 0x27	; 39
    714e:	10 e0       	ldi	r17, 0x00	; 0
    7150:	f8 01       	movw	r30, r16
    7152:	90 81       	ld	r25, Z
    7154:	90 62       	ori	r25, 0x20	; 32
    7156:	90 83       	st	Z, r25
	blink(ubCode);
    7158:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <blink>
	LED_PORT = 0;
    715c:	18 b8       	out	0x08, r1	; 8
	LED_DDR = 0;
    715e:	f8 01       	movw	r30, r16
    7160:	10 82       	st	Z, r1
	asm("jmp 0000");
    7162:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
}
    7166:	1f 91       	pop	r17
    7168:	0f 91       	pop	r16
    716a:	08 95       	ret

0000716c <bootReadPageFromAmi>:
 * - next, 128 bytes are sent by Ami, each of them confirmed by alternating POUT
 *   state, which is followed by Plip read confirm by alternating BUSY.
 * After successful sending, last POUT state should be high, but Ami is expected
 * to set it low afterwards.
 */
uint8_t bootReadPageFromAmi(void) {
    716c:	9f 92       	push	r9
    716e:	af 92       	push	r10
    7170:	bf 92       	push	r11
    7172:	cf 92       	push	r12
    7174:	df 92       	push	r13
    7176:	ef 92       	push	r14
    7178:	ff 92       	push	r15
    717a:	0f 93       	push	r16
    717c:	1f 93       	push	r17
    717e:	cf 93       	push	r28
    7180:	df 93       	push	r29
  uint8_t *pPageByteBfr = (uint8_t*)g_pPageBuffer;
  uint8_t ubPOutWait = 0;
  uint8_t i;

	// Read page idx
  if(!waitForStatusPin(POUT_PIN, 1)) // Wait for ready state from Ami
    7182:	83 e0       	ldi	r24, 0x03	; 3
    7184:	61 e0       	ldi	r22, 0x01	; 1
    7186:	0e 94 48 38 	call	0x7090	; 0x7090 <waitForStatusPin>
    718a:	88 23       	and	r24, r24
    718c:	b9 f1       	breq	.+110    	; 0x71fc <bootReadPageFromAmi+0x90>
		return 0;
  g_ubPageIdx = PAR_DATA_PIN;        // Read byte
    718e:	89 b1       	in	r24, 0x09	; 9
    7190:	80 93 80 01 	sts	0x0180, r24
  PAR_STATUS_PORT &= ~BUSY;          // Confirm read
    7194:	e8 e2       	ldi	r30, 0x28	; 40
    7196:	f0 e0       	ldi	r31, 0x00	; 0
    7198:	80 81       	ld	r24, Z
    719a:	8b 7f       	andi	r24, 0xFB	; 251
    719c:	80 83       	st	Z, r24
    719e:	c0 e0       	ldi	r28, 0x00	; 0
    71a0:	d1 e0       	ldi	r29, 0x01	; 1
    71a2:	10 e0       	ldi	r17, 0x00	; 0

  // Read page bytes
  for(i = 0; i != BOOT_PAGE_BYTE_SIZE; ++i) {
    if(!waitForStatusPin(POUT_PIN, ubPOutWait))
      return 0;
    pPageByteBfr[i] = PAR_DATA_PIN;
    71a4:	0f 2e       	mov	r0, r31
    71a6:	f9 e2       	ldi	r31, 0x29	; 41
    71a8:	af 2e       	mov	r10, r31
    71aa:	bb 24       	eor	r11, r11
    71ac:	f0 2d       	mov	r31, r0
    PAR_STATUS_PORT ^= BUSY;
    71ae:	0f 2e       	mov	r0, r31
    71b0:	f8 e2       	ldi	r31, 0x28	; 40
    71b2:	ef 2e       	mov	r14, r31
    71b4:	ff 24       	eor	r15, r15
    71b6:	f0 2d       	mov	r31, r0
    71b8:	99 24       	eor	r9, r9
    71ba:	68 94       	set
    71bc:	92 f8       	bld	r9, 2
		return 0;
  g_ubPageIdx = PAR_DATA_PIN;        // Read byte
  PAR_STATUS_PORT &= ~BUSY;          // Confirm read

  // Read page bytes
  for(i = 0; i != BOOT_PAGE_BYTE_SIZE; ++i) {
    71be:	0f 2e       	mov	r0, r31
    71c0:	f0 e8       	ldi	r31, 0x80	; 128
    71c2:	cf 2e       	mov	r12, r31
    71c4:	f1 e0       	ldi	r31, 0x01	; 1
    71c6:	df 2e       	mov	r13, r31
    71c8:	f0 2d       	mov	r31, r0
    if(!waitForStatusPin(POUT_PIN, ubPOutWait))
      return 0;
    pPageByteBfr[i] = PAR_DATA_PIN;
    PAR_STATUS_PORT ^= BUSY;
    ubPOutWait ^= 1;
    71ca:	01 e0       	ldi	r16, 0x01	; 1
  g_ubPageIdx = PAR_DATA_PIN;        // Read byte
  PAR_STATUS_PORT &= ~BUSY;          // Confirm read

  // Read page bytes
  for(i = 0; i != BOOT_PAGE_BYTE_SIZE; ++i) {
    if(!waitForStatusPin(POUT_PIN, ubPOutWait))
    71cc:	83 e0       	ldi	r24, 0x03	; 3
    71ce:	61 2f       	mov	r22, r17
    71d0:	0e 94 48 38 	call	0x7090	; 0x7090 <waitForStatusPin>
    71d4:	88 23       	and	r24, r24
    71d6:	91 f0       	breq	.+36     	; 0x71fc <bootReadPageFromAmi+0x90>
      return 0;
    pPageByteBfr[i] = PAR_DATA_PIN;
    71d8:	f5 01       	movw	r30, r10
    71da:	80 81       	ld	r24, Z
    71dc:	89 93       	st	Y+, r24
    PAR_STATUS_PORT ^= BUSY;
    71de:	f7 01       	movw	r30, r14
    71e0:	80 81       	ld	r24, Z
    71e2:	89 25       	eor	r24, r9
    71e4:	80 83       	st	Z, r24
		return 0;
  g_ubPageIdx = PAR_DATA_PIN;        // Read byte
  PAR_STATUS_PORT &= ~BUSY;          // Confirm read

  // Read page bytes
  for(i = 0; i != BOOT_PAGE_BYTE_SIZE; ++i) {
    71e6:	cc 15       	cp	r28, r12
    71e8:	dd 05       	cpc	r29, r13
    71ea:	11 f0       	breq	.+4      	; 0x71f0 <bootReadPageFromAmi+0x84>
    if(!waitForStatusPin(POUT_PIN, ubPOutWait))
      return 0;
    pPageByteBfr[i] = PAR_DATA_PIN;
    PAR_STATUS_PORT ^= BUSY;
    ubPOutWait ^= 1;
    71ec:	10 27       	eor	r17, r16
    71ee:	ee cf       	rjmp	.-36     	; 0x71cc <bootReadPageFromAmi+0x60>
	}

	waitForStatusPin(POUT_PIN, 0);
    71f0:	83 e0       	ldi	r24, 0x03	; 3
    71f2:	60 e0       	ldi	r22, 0x00	; 0
    71f4:	0e 94 48 38 	call	0x7090	; 0x7090 <waitForStatusPin>
    71f8:	81 e0       	ldi	r24, 0x01	; 1
    71fa:	01 c0       	rjmp	.+2      	; 0x71fe <bootReadPageFromAmi+0x92>
  return 1;
    71fc:	80 e0       	ldi	r24, 0x00	; 0
}
    71fe:	df 91       	pop	r29
    7200:	cf 91       	pop	r28
    7202:	1f 91       	pop	r17
    7204:	0f 91       	pop	r16
    7206:	ff 90       	pop	r15
    7208:	ef 90       	pop	r14
    720a:	df 90       	pop	r13
    720c:	cf 90       	pop	r12
    720e:	bf 90       	pop	r11
    7210:	af 90       	pop	r10
    7212:	9f 90       	pop	r9
    7214:	08 95       	ret

00007216 <bootFlashPage>:
	uint8_t ubSreg;
	uint32_t ulPageAddr;
	uint8_t i;

	// Disable interrupts
	ubSreg = SREG;
    7216:	8f b7       	in	r24, 0x3f	; 63
	cli();
    7218:	f8 94       	cli

	// Calculate page address
	ulPageAddr = g_ubPageIdx * BOOT_PAGE_BYTE_SIZE;
    721a:	90 91 80 01 	lds	r25, 0x0180

	// Erase page & wait for completion
  boot_page_erase_safe(ulPageAddr);
    721e:	e7 e5       	ldi	r30, 0x57	; 87
    7220:	f0 e0       	ldi	r31, 0x00	; 0
    7222:	80 81       	ld	r24, Z
    7224:	80 fd       	sbrc	r24, 0
    7226:	fd cf       	rjmp	.-6      	; 0x7222 <bootFlashPage+0xc>
    7228:	ef e3       	ldi	r30, 0x3F	; 63
    722a:	f0 e0       	ldi	r31, 0x00	; 0
    722c:	80 81       	ld	r24, Z
    722e:	81 fd       	sbrc	r24, 1
    7230:	fd cf       	rjmp	.-6      	; 0x722c <bootFlashPage+0x16>
    7232:	89 2f       	mov	r24, r25
    7234:	90 e0       	ldi	r25, 0x00	; 0
    7236:	ac 01       	movw	r20, r24
    7238:	56 95       	lsr	r21
    723a:	54 2f       	mov	r21, r20
    723c:	44 27       	eor	r20, r20
    723e:	57 95       	ror	r21
    7240:	47 95       	ror	r20
    7242:	83 e0       	ldi	r24, 0x03	; 3
    7244:	fa 01       	movw	r30, r20
    7246:	80 93 57 00 	sts	0x0057, r24
    724a:	e8 95       	spm
  boot_spm_busy_wait();
    724c:	e7 e5       	ldi	r30, 0x57	; 87
    724e:	f0 e0       	ldi	r31, 0x00	; 0
    7250:	80 81       	ld	r24, Z
    7252:	80 fd       	sbrc	r24, 0
    7254:	fd cf       	rjmp	.-6      	; 0x7250 <bootFlashPage+0x3a>
    7256:	a0 e0       	ldi	r26, 0x00	; 0
    7258:	b1 e0       	ldi	r27, 0x01	; 1
    725a:	20 e0       	ldi	r18, 0x00	; 0
    725c:	30 e0       	ldi	r19, 0x00	; 0

  // Fill page buffer
  for(i = 0; i != BOOT_PAGE_WORD_SIZE; ++i)
		boot_page_fill(ulPageAddr + (i<<1), g_pPageBuffer[i]);
    725e:	61 e0       	ldi	r22, 0x01	; 1
    7260:	f9 01       	movw	r30, r18
    7262:	ee 0f       	add	r30, r30
    7264:	ff 1f       	adc	r31, r31
    7266:	e4 0f       	add	r30, r20
    7268:	f5 1f       	adc	r31, r21
    726a:	8d 91       	ld	r24, X+
    726c:	9d 91       	ld	r25, X+
    726e:	0c 01       	movw	r0, r24
    7270:	60 93 57 00 	sts	0x0057, r22
    7274:	e8 95       	spm
    7276:	11 24       	eor	r1, r1
    7278:	2f 5f       	subi	r18, 0xFF	; 255
    727a:	3f 4f       	sbci	r19, 0xFF	; 255
	// Erase page & wait for completion
  boot_page_erase_safe(ulPageAddr);
  boot_spm_busy_wait();

  // Fill page buffer
  for(i = 0; i != BOOT_PAGE_WORD_SIZE; ++i)
    727c:	20 34       	cpi	r18, 0x40	; 64
    727e:	31 05       	cpc	r19, r1
    7280:	79 f7       	brne	.-34     	; 0x7260 <bootFlashPage+0x4a>
		boot_page_fill(ulPageAddr + (i<<1), g_pPageBuffer[i]);

  // Write page
  boot_page_write_safe(ulPageAddr);
    7282:	e7 e5       	ldi	r30, 0x57	; 87
    7284:	f0 e0       	ldi	r31, 0x00	; 0
    7286:	80 81       	ld	r24, Z
    7288:	80 fd       	sbrc	r24, 0
    728a:	fd cf       	rjmp	.-6      	; 0x7286 <bootFlashPage+0x70>
    728c:	ef e3       	ldi	r30, 0x3F	; 63
    728e:	f0 e0       	ldi	r31, 0x00	; 0
    7290:	80 81       	ld	r24, Z
    7292:	81 fd       	sbrc	r24, 1
    7294:	fd cf       	rjmp	.-6      	; 0x7290 <bootFlashPage+0x7a>
    7296:	85 e0       	ldi	r24, 0x05	; 5
    7298:	fa 01       	movw	r30, r20
    729a:	80 93 57 00 	sts	0x0057, r24
    729e:	e8 95       	spm
	boot_rww_enable_safe();
    72a0:	e7 e5       	ldi	r30, 0x57	; 87
    72a2:	f0 e0       	ldi	r31, 0x00	; 0
    72a4:	80 81       	ld	r24, Z
    72a6:	80 fd       	sbrc	r24, 0
    72a8:	fd cf       	rjmp	.-6      	; 0x72a4 <bootFlashPage+0x8e>
    72aa:	ef e3       	ldi	r30, 0x3F	; 63
    72ac:	f0 e0       	ldi	r31, 0x00	; 0
    72ae:	80 81       	ld	r24, Z
    72b0:	81 fd       	sbrc	r24, 1
    72b2:	fd cf       	rjmp	.-6      	; 0x72ae <bootFlashPage+0x98>
    72b4:	81 e1       	ldi	r24, 0x11	; 17
    72b6:	80 93 57 00 	sts	0x0057, r24
    72ba:	e8 95       	spm
  ubSreg = SREG;
    72bc:	8f b7       	in	r24, 0x3f	; 63
}
    72be:	08 95       	ret

000072c0 <main>:

int main(void) {
    72c0:	cf 92       	push	r12
    72c2:	df 92       	push	r13
    72c4:	ef 92       	push	r14
    72c6:	ff 92       	push	r15
    72c8:	0f 93       	push	r16
    72ca:	1f 93       	push	r17
    72cc:	df 93       	push	r29
    72ce:	cf 93       	push	r28
    72d0:	0f 92       	push	r0
    72d2:	cd b7       	in	r28, 0x3d	; 61
    72d4:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t ubRequest;
	uint8_t i;

	// Disable watchdog & interrupts
	cli();
    72d6:	f8 94       	cli
	wdt_reset();
    72d8:	a8 95       	wdr
	MCUSR=0;
    72da:	14 be       	out	0x34, r1	; 52
	WDTCSR|=_BV(WDCE) | _BV(WDE);
    72dc:	e0 e6       	ldi	r30, 0x60	; 96
    72de:	f0 e0       	ldi	r31, 0x00	; 0
    72e0:	80 81       	ld	r24, Z
    72e2:	88 61       	ori	r24, 0x18	; 24
    72e4:	80 83       	st	Z, r24
	WDTCSR=0;
    72e6:	10 82       	st	Z, r1

	// Set DDR & pullups
	PAR_STATUS_DDR |= NACK | BUSY;
    72e8:	e7 e2       	ldi	r30, 0x27	; 39
    72ea:	f0 e0       	ldi	r31, 0x00	; 0
    72ec:	80 81       	ld	r24, Z
    72ee:	86 60       	ori	r24, 0x06	; 6
    72f0:	80 83       	st	Z, r24
  PAR_STATUS_PORT |= NSTROBE | SEL | POUT | NACK;
    72f2:	e8 e2       	ldi	r30, 0x28	; 40
    72f4:	f0 e0       	ldi	r31, 0x00	; 0
    72f6:	80 81       	ld	r24, Z
    72f8:	8b 61       	ori	r24, 0x1B	; 27
    72fa:	80 83       	st	Z, r24
	PAR_DATA_DDR = 0;
    72fc:	1a b8       	out	0x0a, r1	; 10
    72fe:	ff 24       	eor	r15, r15

	// Do a bootloader handshake to init programming
	for(i = 0; i != 3; ++i) {
		if(!waitForStatusPin(POUT_PIN, 1))
			bootExit(1);
		PAR_STATUS_PORT &= ~NACK;
    7300:	08 e2       	ldi	r16, 0x28	; 40
    7302:	10 e0       	ldi	r17, 0x00	; 0
    7304:	0f 2e       	mov	r0, r31
    7306:	f8 ea       	ldi	r31, 0xA8	; 168
    7308:	cf 2e       	mov	r12, r31
    730a:	f1 e6       	ldi	r31, 0x61	; 97
    730c:	df 2e       	mov	r13, r31
    730e:	f0 2d       	mov	r31, r0
  PAR_STATUS_PORT |= NSTROBE | SEL | POUT | NACK;
	PAR_DATA_DDR = 0;

	// Do a bootloader handshake to init programming
	for(i = 0; i != 3; ++i) {
		if(!waitForStatusPin(POUT_PIN, 1))
    7310:	83 e0       	ldi	r24, 0x03	; 3
    7312:	61 e0       	ldi	r22, 0x01	; 1
    7314:	0e 94 48 38 	call	0x7090	; 0x7090 <waitForStatusPin>
    7318:	88 23       	and	r24, r24
    731a:	19 f4       	brne	.+6      	; 0x7322 <main+0x62>
			bootExit(1);
    731c:	81 e0       	ldi	r24, 0x01	; 1
    731e:	0e 94 a4 38 	call	0x7148	; 0x7148 <bootExit>
		PAR_STATUS_PORT &= ~NACK;
    7322:	f8 01       	movw	r30, r16
    7324:	80 81       	ld	r24, Z
    7326:	8d 7f       	andi	r24, 0xFD	; 253
    7328:	80 83       	st	Z, r24
    732a:	c6 01       	movw	r24, r12
    732c:	01 97       	sbiw	r24, 0x01	; 1
    732e:	f1 f7       	brne	.-4      	; 0x732c <main+0x6c>
		_delay_ms(5);
		PAR_STATUS_PORT |= NACK;
    7330:	80 81       	ld	r24, Z
    7332:	82 60       	ori	r24, 0x02	; 2
    7334:	80 83       	st	Z, r24
		if(!waitForStatusPin(POUT_PIN, 0))
    7336:	83 e0       	ldi	r24, 0x03	; 3
    7338:	60 e0       	ldi	r22, 0x00	; 0
    733a:	0e 94 48 38 	call	0x7090	; 0x7090 <waitForStatusPin>
    733e:	88 23       	and	r24, r24
    7340:	19 f4       	brne	.+6      	; 0x7348 <main+0x88>
			bootExit(1);
    7342:	81 e0       	ldi	r24, 0x01	; 1
    7344:	0e 94 a4 38 	call	0x7148	; 0x7148 <bootExit>
		PAR_STATUS_PORT &= ~NACK;
    7348:	f8 01       	movw	r30, r16
    734a:	80 81       	ld	r24, Z
    734c:	8d 7f       	andi	r24, 0xFD	; 253
    734e:	80 83       	st	Z, r24
    7350:	c6 01       	movw	r24, r12
    7352:	01 97       	sbiw	r24, 0x01	; 1
    7354:	f1 f7       	brne	.-4      	; 0x7352 <main+0x92>
		_delay_ms(5);
		PAR_STATUS_PORT |= NACK;
    7356:	80 81       	ld	r24, Z
    7358:	82 60       	ori	r24, 0x02	; 2
    735a:	80 83       	st	Z, r24
	PAR_STATUS_DDR |= NACK | BUSY;
  PAR_STATUS_PORT |= NSTROBE | SEL | POUT | NACK;
	PAR_DATA_DDR = 0;

	// Do a bootloader handshake to init programming
	for(i = 0; i != 3; ++i) {
    735c:	f3 94       	inc	r15
    735e:	f3 e0       	ldi	r31, 0x03	; 3
    7360:	ff 16       	cp	r15, r31
    7362:	b1 f6       	brne	.-84     	; 0x7310 <main+0x50>

	while(1) {
		// Wait for read request from Ami
		if(!waitForStatusPin(SEL_PIN, 1))
			bootExit(3);
		ubRequest = PAR_DATA_PIN;
    7364:	0f 2e       	mov	r0, r31
    7366:	f9 e2       	ldi	r31, 0x29	; 41
    7368:	cf 2e       	mov	r12, r31
    736a:	dd 24       	eor	r13, r13
    736c:	f0 2d       	mov	r31, r0
		PAR_STATUS_PORT |= BUSY;
    736e:	08 e2       	ldi	r16, 0x28	; 40
    7370:	10 e0       	ldi	r17, 0x00	; 0
    7372:	0f 2e       	mov	r0, r31
    7374:	f0 e1       	ldi	r31, 0x10	; 16
    7376:	ef 2e       	mov	r14, r31
    7378:	f7 e2       	ldi	r31, 0x27	; 39
    737a:	ff 2e       	mov	r15, r31
    737c:	f0 2d       	mov	r31, r0
		PAR_STATUS_PORT |= NACK;
	}

	while(1) {
		// Wait for read request from Ami
		if(!waitForStatusPin(SEL_PIN, 1))
    737e:	84 e0       	ldi	r24, 0x04	; 4
    7380:	61 e0       	ldi	r22, 0x01	; 1
    7382:	0e 94 48 38 	call	0x7090	; 0x7090 <waitForStatusPin>
    7386:	88 23       	and	r24, r24
    7388:	19 f4       	brne	.+6      	; 0x7390 <main+0xd0>
			bootExit(3);
    738a:	83 e0       	ldi	r24, 0x03	; 3
    738c:	0e 94 a4 38 	call	0x7148	; 0x7148 <bootExit>
		ubRequest = PAR_DATA_PIN;
    7390:	f6 01       	movw	r30, r12
    7392:	80 81       	ld	r24, Z
    7394:	89 83       	std	Y+1, r24	; 0x01
		PAR_STATUS_PORT |= BUSY;
    7396:	f8 01       	movw	r30, r16
    7398:	80 81       	ld	r24, Z
    739a:	84 60       	ori	r24, 0x04	; 4
    739c:	80 83       	st	Z, r24

		// Abort if request is not flash-related
		if(ubRequest != CMD_SEND_BOOT)
    739e:	89 81       	ldd	r24, Y+1	; 0x01
    73a0:	88 38       	cpi	r24, 0x88	; 136
    73a2:	19 f0       	breq	.+6      	; 0x73aa <main+0xea>
			bootExit(4); // 4
    73a4:	84 e0       	ldi	r24, 0x04	; 4
    73a6:	0e 94 a4 38 	call	0x7148	; 0x7148 <bootExit>

		// Read page from Ami
		if(!bootReadPageFromAmi())
    73aa:	0e 94 b6 38 	call	0x716c	; 0x716c <bootReadPageFromAmi>
    73ae:	88 23       	and	r24, r24
    73b0:	19 f4       	brne	.+6      	; 0x73b8 <main+0xf8>
			bootExit(5);
    73b2:	85 e0       	ldi	r24, 0x05	; 5
    73b4:	0e 94 a4 38 	call	0x7148	; 0x7148 <bootExit>

		// Program page on flash & wait for Ami read
		bootFlashPage();
    73b8:	0e 94 0b 39 	call	0x7216	; 0x7216 <bootFlashPage>

		// Let Ami know that bootloader is ready for more
		PAR_STATUS_PORT |= NACK;
    73bc:	f8 01       	movw	r30, r16
    73be:	80 81       	ld	r24, Z
    73c0:	82 60       	ori	r24, 0x02	; 2
    73c2:	80 83       	st	Z, r24
    73c4:	c7 01       	movw	r24, r14
    73c6:	01 97       	sbiw	r24, 0x01	; 1
    73c8:	f1 f7       	brne	.-4      	; 0x73c6 <main+0x106>
		_delay_ms(2);
		PAR_STATUS_PORT &= ~NACK;
    73ca:	80 81       	ld	r24, Z
    73cc:	8d 7f       	andi	r24, 0xFD	; 253
    73ce:	80 83       	st	Z, r24
    73d0:	d6 cf       	rjmp	.-84     	; 0x737e <main+0xbe>

000073d2 <_exit>:
    73d2:	f8 94       	cli

000073d4 <__stop_program>:
    73d4:	ff cf       	rjmp	.-2      	; 0x73d4 <__stop_program>

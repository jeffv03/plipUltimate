
bin\Debug\avr-bootloader.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000316  00007000  00007000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000081  00800100  00800100  0000038a  2**0
                  ALLOC
  2 .debug_aranges 00000020  00000000  00000000  0000038a  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 00000089  00000000  00000000  000003aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000003aa  00000000  00000000  00000433  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000190  00000000  00000000  000007dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000381  00000000  00000000  0000096d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000060  00000000  00000000  00000cf0  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000018c  00000000  00000000  00000d50  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000118  00000000  00000000  00000edc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000000c0  00000000  00000000  00000ff4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	0c 94 34 38 	jmp	0x7068	; 0x7068 <__ctors_end>
    7004:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7008:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    700c:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7010:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7014:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7018:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    701c:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7020:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7024:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7028:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    702c:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7030:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7034:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7038:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    703c:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7040:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7044:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7048:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    704c:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7050:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7054:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7058:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    705c:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7060:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>
    7064:	0c 94 46 38 	jmp	0x708c	; 0x708c <__bad_interrupt>

00007068 <__ctors_end>:
    7068:	11 24       	eor	r1, r1
    706a:	1f be       	out	0x3f, r1	; 63
    706c:	cf ef       	ldi	r28, 0xFF	; 255
    706e:	d8 e0       	ldi	r29, 0x08	; 8
    7070:	de bf       	out	0x3e, r29	; 62
    7072:	cd bf       	out	0x3d, r28	; 61

00007074 <__do_clear_bss>:
    7074:	11 e0       	ldi	r17, 0x01	; 1
    7076:	a0 e0       	ldi	r26, 0x00	; 0
    7078:	b1 e0       	ldi	r27, 0x01	; 1
    707a:	01 c0       	rjmp	.+2      	; 0x707e <.do_clear_bss_start>

0000707c <.do_clear_bss_loop>:
    707c:	1d 92       	st	X+, r1

0000707e <.do_clear_bss_start>:
    707e:	a1 38       	cpi	r26, 0x81	; 129
    7080:	b1 07       	cpc	r27, r17
    7082:	e1 f7       	brne	.-8      	; 0x707c <.do_clear_bss_loop>
    7084:	0e 94 32 39 	call	0x7264	; 0x7264 <main>
    7088:	0c 94 89 39 	jmp	0x7312	; 0x7312 <_exit>

0000708c <__bad_interrupt>:
    708c:	0c 94 00 38 	jmp	0x7000	; 0x7000 <__vectors>

00007090 <waitForStatusPin>:
/**
 * Boot write mode to differentiate from regular plip operation
 */
#define CMD_SEND_BOOT 0x88

uint8_t waitForStatusPin(uint8_t ubStatusPin, uint8_t ubValue) {
    7090:	a8 2f       	mov	r26, r24
    7092:	20 e0       	ldi	r18, 0x00	; 0
    7094:	30 e0       	ldi	r19, 0x00	; 0
	uint16_t uwCounter = 0;
	while((uwCounter < 1000)) {
		if(((PAR_STATUS_PIN >> ubStatusPin) & 1) == ubValue)
    7096:	e6 e2       	ldi	r30, 0x26	; 38
    7098:	f0 e0       	ldi	r31, 0x00	; 0
    709a:	70 e0       	ldi	r23, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    709c:	48 e8       	ldi	r20, 0x88	; 136
    709e:	53 e1       	ldi	r21, 0x13	; 19
    70a0:	80 81       	ld	r24, Z
    70a2:	90 e0       	ldi	r25, 0x00	; 0
    70a4:	0a 2e       	mov	r0, r26
    70a6:	02 c0       	rjmp	.+4      	; 0x70ac <waitForStatusPin+0x1c>
    70a8:	95 95       	asr	r25
    70aa:	87 95       	ror	r24
    70ac:	0a 94       	dec	r0
    70ae:	e2 f7       	brpl	.-8      	; 0x70a8 <waitForStatusPin+0x18>
    70b0:	81 70       	andi	r24, 0x01	; 1
    70b2:	90 70       	andi	r25, 0x00	; 0
    70b4:	86 17       	cp	r24, r22
    70b6:	97 07       	cpc	r25, r23
    70b8:	11 f4       	brne	.+4      	; 0x70be <waitForStatusPin+0x2e>
    70ba:	81 e0       	ldi	r24, 0x01	; 1
    70bc:	08 95       	ret
			return 1;
		++uwCounter;
    70be:	2f 5f       	subi	r18, 0xFF	; 255
    70c0:	3f 4f       	sbci	r19, 0xFF	; 255
    70c2:	ca 01       	movw	r24, r20
    70c4:	01 97       	sbiw	r24, 0x01	; 1
    70c6:	f1 f7       	brne	.-4      	; 0x70c4 <waitForStatusPin+0x34>
 */
#define CMD_SEND_BOOT 0x88

uint8_t waitForStatusPin(uint8_t ubStatusPin, uint8_t ubValue) {
	uint16_t uwCounter = 0;
	while((uwCounter < 1000)) {
    70c8:	83 e0       	ldi	r24, 0x03	; 3
    70ca:	28 3e       	cpi	r18, 0xE8	; 232
    70cc:	38 07       	cpc	r19, r24
    70ce:	41 f7       	brne	.-48     	; 0x70a0 <waitForStatusPin+0x10>
    70d0:	80 e0       	ldi	r24, 0x00	; 0
			return 1;
		++uwCounter;
		_delay_us(1000);
	}
	return 0;
}
    70d2:	08 95       	ret

000070d4 <bootExit>:

void bootExit(void) {
	LED_DDR |= _BV(PC5);
    70d4:	e7 e2       	ldi	r30, 0x27	; 39
    70d6:	f0 e0       	ldi	r31, 0x00	; 0
    70d8:	80 81       	ld	r24, Z
    70da:	80 62       	ori	r24, 0x20	; 32
    70dc:	80 83       	st	Z, r24
    70de:	28 ec       	ldi	r18, 0xC8	; 200
    70e0:	30 e0       	ldi	r19, 0x00	; 0
    70e2:	44 ef       	ldi	r20, 0xF4	; 244
    70e4:	51 e0       	ldi	r21, 0x01	; 1
    70e6:	ca 01       	movw	r24, r20
    70e8:	01 97       	sbiw	r24, 0x01	; 1
    70ea:	f1 f7       	brne	.-4      	; 0x70e8 <bootExit+0x14>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    70ec:	21 50       	subi	r18, 0x01	; 1
    70ee:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    70f0:	d1 f7       	brne	.-12     	; 0x70e6 <bootExit+0x12>
	_delay_ms(20);
	LED_DDR = 0;
    70f2:	17 b8       	out	0x07, r1	; 7
	LED_PORT = 0;
    70f4:	18 b8       	out	0x08, r1	; 8
    70f6:	28 ec       	ldi	r18, 0xC8	; 200
    70f8:	30 e0       	ldi	r19, 0x00	; 0
    70fa:	44 ef       	ldi	r20, 0xF4	; 244
    70fc:	51 e0       	ldi	r21, 0x01	; 1
    70fe:	ca 01       	movw	r24, r20
    7100:	01 97       	sbiw	r24, 0x01	; 1
    7102:	f1 f7       	brne	.-4      	; 0x7100 <bootExit+0x2c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7104:	21 50       	subi	r18, 0x01	; 1
    7106:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7108:	d1 f7       	brne	.-12     	; 0x70fe <bootExit+0x2a>
	_delay_ms(20);
	asm("jmp 0000");
    710a:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
}
    710e:	08 95       	ret

00007110 <bootReadPageFromAmi>:
 * - next, 128 bytes are sent by Ami, each of them confirmed by alternating POUT
 *   state, which is followed by Plip read confirm by alternating BUSY.
 * After successful sending, last POUT state should be high, but Ami is expected
 * to set it low afterwards.
 */
uint8_t bootReadPageFromAmi(void) {
    7110:	9f 92       	push	r9
    7112:	af 92       	push	r10
    7114:	bf 92       	push	r11
    7116:	cf 92       	push	r12
    7118:	df 92       	push	r13
    711a:	ef 92       	push	r14
    711c:	ff 92       	push	r15
    711e:	0f 93       	push	r16
    7120:	1f 93       	push	r17
    7122:	cf 93       	push	r28
    7124:	df 93       	push	r29
  uint8_t *pPageByteBfr = (uint8_t*)g_pPageBuffer;
  uint8_t ubPOutWait = 0;
  uint8_t i;

	// Read page idx
  if(!waitForStatusPin(POUT_PIN, 1)) // Wait for ready state from Ami
    7126:	83 e0       	ldi	r24, 0x03	; 3
    7128:	61 e0       	ldi	r22, 0x01	; 1
    712a:	0e 94 48 38 	call	0x7090	; 0x7090 <waitForStatusPin>
    712e:	88 23       	and	r24, r24
    7130:	b9 f1       	breq	.+110    	; 0x71a0 <bootReadPageFromAmi+0x90>
		return 0;
  g_ubPageIdx = PAR_DATA_PIN;        // Read byte
    7132:	89 b1       	in	r24, 0x09	; 9
    7134:	80 93 80 01 	sts	0x0180, r24
  PAR_STATUS_PORT &= ~BUSY;          // Confirm read
    7138:	e8 e2       	ldi	r30, 0x28	; 40
    713a:	f0 e0       	ldi	r31, 0x00	; 0
    713c:	80 81       	ld	r24, Z
    713e:	8b 7f       	andi	r24, 0xFB	; 251
    7140:	80 83       	st	Z, r24
    7142:	c0 e0       	ldi	r28, 0x00	; 0
    7144:	d1 e0       	ldi	r29, 0x01	; 1
    7146:	10 e0       	ldi	r17, 0x00	; 0

  // Read page bytes
  for(i = 0; i != BOOT_PAGE_BYTE_SIZE; ++i) {
    if(!waitForStatusPin(POUT_PIN, ubPOutWait))
      return 0;
    pPageByteBfr[i] = PAR_DATA_PIN;
    7148:	0f 2e       	mov	r0, r31
    714a:	f9 e2       	ldi	r31, 0x29	; 41
    714c:	af 2e       	mov	r10, r31
    714e:	bb 24       	eor	r11, r11
    7150:	f0 2d       	mov	r31, r0
    PAR_STATUS_PORT ^= BUSY;
    7152:	0f 2e       	mov	r0, r31
    7154:	f8 e2       	ldi	r31, 0x28	; 40
    7156:	ef 2e       	mov	r14, r31
    7158:	ff 24       	eor	r15, r15
    715a:	f0 2d       	mov	r31, r0
    715c:	99 24       	eor	r9, r9
    715e:	68 94       	set
    7160:	92 f8       	bld	r9, 2
		return 0;
  g_ubPageIdx = PAR_DATA_PIN;        // Read byte
  PAR_STATUS_PORT &= ~BUSY;          // Confirm read

  // Read page bytes
  for(i = 0; i != BOOT_PAGE_BYTE_SIZE; ++i) {
    7162:	0f 2e       	mov	r0, r31
    7164:	f0 e8       	ldi	r31, 0x80	; 128
    7166:	cf 2e       	mov	r12, r31
    7168:	f1 e0       	ldi	r31, 0x01	; 1
    716a:	df 2e       	mov	r13, r31
    716c:	f0 2d       	mov	r31, r0
    if(!waitForStatusPin(POUT_PIN, ubPOutWait))
      return 0;
    pPageByteBfr[i] = PAR_DATA_PIN;
    PAR_STATUS_PORT ^= BUSY;
    ubPOutWait ^= 1;
    716e:	01 e0       	ldi	r16, 0x01	; 1
  g_ubPageIdx = PAR_DATA_PIN;        // Read byte
  PAR_STATUS_PORT &= ~BUSY;          // Confirm read

  // Read page bytes
  for(i = 0; i != BOOT_PAGE_BYTE_SIZE; ++i) {
    if(!waitForStatusPin(POUT_PIN, ubPOutWait))
    7170:	83 e0       	ldi	r24, 0x03	; 3
    7172:	61 2f       	mov	r22, r17
    7174:	0e 94 48 38 	call	0x7090	; 0x7090 <waitForStatusPin>
    7178:	88 23       	and	r24, r24
    717a:	91 f0       	breq	.+36     	; 0x71a0 <bootReadPageFromAmi+0x90>
      return 0;
    pPageByteBfr[i] = PAR_DATA_PIN;
    717c:	f5 01       	movw	r30, r10
    717e:	80 81       	ld	r24, Z
    7180:	89 93       	st	Y+, r24
    PAR_STATUS_PORT ^= BUSY;
    7182:	f7 01       	movw	r30, r14
    7184:	80 81       	ld	r24, Z
    7186:	89 25       	eor	r24, r9
    7188:	80 83       	st	Z, r24
		return 0;
  g_ubPageIdx = PAR_DATA_PIN;        // Read byte
  PAR_STATUS_PORT &= ~BUSY;          // Confirm read

  // Read page bytes
  for(i = 0; i != BOOT_PAGE_BYTE_SIZE; ++i) {
    718a:	cc 15       	cp	r28, r12
    718c:	dd 05       	cpc	r29, r13
    718e:	11 f0       	breq	.+4      	; 0x7194 <bootReadPageFromAmi+0x84>
    if(!waitForStatusPin(POUT_PIN, ubPOutWait))
      return 0;
    pPageByteBfr[i] = PAR_DATA_PIN;
    PAR_STATUS_PORT ^= BUSY;
    ubPOutWait ^= 1;
    7190:	10 27       	eor	r17, r16
    7192:	ee cf       	rjmp	.-36     	; 0x7170 <bootReadPageFromAmi+0x60>
	}

	waitForStatusPin(POUT_PIN, 0);
    7194:	83 e0       	ldi	r24, 0x03	; 3
    7196:	60 e0       	ldi	r22, 0x00	; 0
    7198:	0e 94 48 38 	call	0x7090	; 0x7090 <waitForStatusPin>
    719c:	81 e0       	ldi	r24, 0x01	; 1
    719e:	01 c0       	rjmp	.+2      	; 0x71a2 <bootReadPageFromAmi+0x92>
  return 1;
    71a0:	80 e0       	ldi	r24, 0x00	; 0
}
    71a2:	df 91       	pop	r29
    71a4:	cf 91       	pop	r28
    71a6:	1f 91       	pop	r17
    71a8:	0f 91       	pop	r16
    71aa:	ff 90       	pop	r15
    71ac:	ef 90       	pop	r14
    71ae:	df 90       	pop	r13
    71b0:	cf 90       	pop	r12
    71b2:	bf 90       	pop	r11
    71b4:	af 90       	pop	r10
    71b6:	9f 90       	pop	r9
    71b8:	08 95       	ret

000071ba <bootFlashPage>:
	uint8_t ubSreg;
	uint32_t ulPageAddr;
	uint8_t i;

	// Disable interrupts
	ubSreg = SREG;
    71ba:	8f b7       	in	r24, 0x3f	; 63
	cli();
    71bc:	f8 94       	cli

	// Calculate page address
	ulPageAddr = g_ubPageIdx * BOOT_PAGE_BYTE_SIZE;
    71be:	90 91 80 01 	lds	r25, 0x0180

	// Erase page & wait for completion
  boot_page_erase_safe(ulPageAddr);
    71c2:	e7 e5       	ldi	r30, 0x57	; 87
    71c4:	f0 e0       	ldi	r31, 0x00	; 0
    71c6:	80 81       	ld	r24, Z
    71c8:	80 fd       	sbrc	r24, 0
    71ca:	fd cf       	rjmp	.-6      	; 0x71c6 <bootFlashPage+0xc>
    71cc:	ef e3       	ldi	r30, 0x3F	; 63
    71ce:	f0 e0       	ldi	r31, 0x00	; 0
    71d0:	80 81       	ld	r24, Z
    71d2:	81 fd       	sbrc	r24, 1
    71d4:	fd cf       	rjmp	.-6      	; 0x71d0 <bootFlashPage+0x16>
    71d6:	89 2f       	mov	r24, r25
    71d8:	90 e0       	ldi	r25, 0x00	; 0
    71da:	ac 01       	movw	r20, r24
    71dc:	56 95       	lsr	r21
    71de:	54 2f       	mov	r21, r20
    71e0:	44 27       	eor	r20, r20
    71e2:	57 95       	ror	r21
    71e4:	47 95       	ror	r20
    71e6:	83 e0       	ldi	r24, 0x03	; 3
    71e8:	fa 01       	movw	r30, r20
    71ea:	80 93 57 00 	sts	0x0057, r24
    71ee:	e8 95       	spm
  boot_spm_busy_wait();
    71f0:	e7 e5       	ldi	r30, 0x57	; 87
    71f2:	f0 e0       	ldi	r31, 0x00	; 0
    71f4:	80 81       	ld	r24, Z
    71f6:	80 fd       	sbrc	r24, 0
    71f8:	fd cf       	rjmp	.-6      	; 0x71f4 <bootFlashPage+0x3a>
    71fa:	a0 e0       	ldi	r26, 0x00	; 0
    71fc:	b1 e0       	ldi	r27, 0x01	; 1
    71fe:	20 e0       	ldi	r18, 0x00	; 0
    7200:	30 e0       	ldi	r19, 0x00	; 0

  // Fill page buffer
  for(i = 0; i != BOOT_PAGE_WORD_SIZE; ++i)
		boot_page_fill(ulPageAddr + (i<<1), g_pPageBuffer[i]);
    7202:	61 e0       	ldi	r22, 0x01	; 1
    7204:	f9 01       	movw	r30, r18
    7206:	ee 0f       	add	r30, r30
    7208:	ff 1f       	adc	r31, r31
    720a:	e4 0f       	add	r30, r20
    720c:	f5 1f       	adc	r31, r21
    720e:	8d 91       	ld	r24, X+
    7210:	9d 91       	ld	r25, X+
    7212:	0c 01       	movw	r0, r24
    7214:	60 93 57 00 	sts	0x0057, r22
    7218:	e8 95       	spm
    721a:	11 24       	eor	r1, r1
    721c:	2f 5f       	subi	r18, 0xFF	; 255
    721e:	3f 4f       	sbci	r19, 0xFF	; 255
	// Erase page & wait for completion
  boot_page_erase_safe(ulPageAddr);
  boot_spm_busy_wait();

  // Fill page buffer
  for(i = 0; i != BOOT_PAGE_WORD_SIZE; ++i)
    7220:	20 34       	cpi	r18, 0x40	; 64
    7222:	31 05       	cpc	r19, r1
    7224:	79 f7       	brne	.-34     	; 0x7204 <bootFlashPage+0x4a>
		boot_page_fill(ulPageAddr + (i<<1), g_pPageBuffer[i]);

  // Write page
  boot_page_write_safe(ulPageAddr);
    7226:	e7 e5       	ldi	r30, 0x57	; 87
    7228:	f0 e0       	ldi	r31, 0x00	; 0
    722a:	80 81       	ld	r24, Z
    722c:	80 fd       	sbrc	r24, 0
    722e:	fd cf       	rjmp	.-6      	; 0x722a <bootFlashPage+0x70>
    7230:	ef e3       	ldi	r30, 0x3F	; 63
    7232:	f0 e0       	ldi	r31, 0x00	; 0
    7234:	80 81       	ld	r24, Z
    7236:	81 fd       	sbrc	r24, 1
    7238:	fd cf       	rjmp	.-6      	; 0x7234 <bootFlashPage+0x7a>
    723a:	85 e0       	ldi	r24, 0x05	; 5
    723c:	fa 01       	movw	r30, r20
    723e:	80 93 57 00 	sts	0x0057, r24
    7242:	e8 95       	spm
	boot_rww_enable_safe();
    7244:	e7 e5       	ldi	r30, 0x57	; 87
    7246:	f0 e0       	ldi	r31, 0x00	; 0
    7248:	80 81       	ld	r24, Z
    724a:	80 fd       	sbrc	r24, 0
    724c:	fd cf       	rjmp	.-6      	; 0x7248 <bootFlashPage+0x8e>
    724e:	ef e3       	ldi	r30, 0x3F	; 63
    7250:	f0 e0       	ldi	r31, 0x00	; 0
    7252:	80 81       	ld	r24, Z
    7254:	81 fd       	sbrc	r24, 1
    7256:	fd cf       	rjmp	.-6      	; 0x7252 <bootFlashPage+0x98>
    7258:	81 e1       	ldi	r24, 0x11	; 17
    725a:	80 93 57 00 	sts	0x0057, r24
    725e:	e8 95       	spm
  ubSreg = SREG;
    7260:	8f b7       	in	r24, 0x3f	; 63
}
    7262:	08 95       	ret

00007264 <main>:

int main(void) {
    7264:	ef 92       	push	r14
    7266:	ff 92       	push	r15
    7268:	0f 93       	push	r16
    726a:	1f 93       	push	r17
    726c:	cf 93       	push	r28
    726e:	df 93       	push	r29
	// Disable watchdog & interrupts
	cli();
    7270:	f8 94       	cli
	wdt_reset();
    7272:	a8 95       	wdr
	MCUSR=0;
    7274:	14 be       	out	0x34, r1	; 52
	WDTCSR|=_BV(WDCE) | _BV(WDE);
    7276:	e0 e6       	ldi	r30, 0x60	; 96
    7278:	f0 e0       	ldi	r31, 0x00	; 0
    727a:	80 81       	ld	r24, Z
    727c:	88 61       	ori	r24, 0x18	; 24
    727e:	80 83       	st	Z, r24
	WDTCSR=0;
    7280:	10 82       	st	Z, r1

	// Bootloader ready for flashing - set POUT hi for 1 second and wait for SEL
	LED_PORT = _BV(PC5);
    7282:	e8 e2       	ldi	r30, 0x28	; 40
    7284:	f0 e0       	ldi	r31, 0x00	; 0
    7286:	80 e2       	ldi	r24, 0x20	; 32
    7288:	80 83       	st	Z, r24
	PAR_STATUS_DDR = POUT;
    728a:	88 e0       	ldi	r24, 0x08	; 8
    728c:	87 b9       	out	0x07, r24	; 7
	PAR_STATUS_PORT = POUT;
    728e:	80 83       	st	Z, r24

	// Exit bootloader if Ami doesn't respond
	if(!waitForStatusPin(BUSY_PIN, 1))
    7290:	82 e0       	ldi	r24, 0x02	; 2
    7292:	61 e0       	ldi	r22, 0x01	; 1
    7294:	0e 94 48 38 	call	0x7090	; 0x7090 <waitForStatusPin>
    7298:	88 23       	and	r24, r24
    729a:	11 f4       	brne	.+4      	; 0x72a0 <main+0x3c>
		bootExit();
    729c:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <bootExit>

	PAR_STATUS_PORT = 0;
    72a0:	18 b8       	out	0x08, r1	; 8
	PAR_STATUS_DDR = BUSY | NACK;
    72a2:	86 e0       	ldi	r24, 0x06	; 6
    72a4:	87 b9       	out	0x07, r24	; 7
	uint8_t ubRequest;
	while(1) {
		// Wait for request from Ami
		if((PAR_STATUS_PORT & SEL) && !(PAR_STATUS_PORT & POUT)) {
    72a6:	c8 e2       	ldi	r28, 0x28	; 40
    72a8:	d0 e0       	ldi	r29, 0x00	; 0
    72aa:	0f 2e       	mov	r0, r31
    72ac:	f0 e1       	ldi	r31, 0x10	; 16
    72ae:	ef 2e       	mov	r14, r31
    72b0:	f7 e2       	ldi	r31, 0x27	; 39
    72b2:	ff 2e       	mov	r15, r31
    72b4:	f0 2d       	mov	r31, r0
			_delay_ms(2);
			continue;
		}

		// Abort if request is not flash-related
		ubRequest = PAR_DATA_PIN;
    72b6:	09 e2       	ldi	r16, 0x29	; 41
    72b8:	10 e0       	ldi	r17, 0x00	; 0
	PAR_STATUS_PORT = 0;
	PAR_STATUS_DDR = BUSY | NACK;
	uint8_t ubRequest;
	while(1) {
		// Wait for request from Ami
		if((PAR_STATUS_PORT & SEL) && !(PAR_STATUS_PORT & POUT)) {
    72ba:	88 81       	ld	r24, Y
    72bc:	84 ff       	sbrs	r24, 4
    72be:	07 c0       	rjmp	.+14     	; 0x72ce <main+0x6a>
    72c0:	88 81       	ld	r24, Y
    72c2:	83 fd       	sbrc	r24, 3
    72c4:	04 c0       	rjmp	.+8      	; 0x72ce <main+0x6a>
    72c6:	c7 01       	movw	r24, r14
    72c8:	01 97       	sbiw	r24, 0x01	; 1
    72ca:	f1 f7       	brne	.-4      	; 0x72c8 <main+0x64>
    72cc:	f6 cf       	rjmp	.-20     	; 0x72ba <main+0x56>
			_delay_ms(2);
			continue;
		}

		// Abort if request is not flash-related
		ubRequest = PAR_DATA_PIN;
    72ce:	f8 01       	movw	r30, r16
    72d0:	90 81       	ld	r25, Z
		PAR_STATUS_PORT |= BUSY;
    72d2:	88 81       	ld	r24, Y
    72d4:	84 60       	ori	r24, 0x04	; 4
    72d6:	88 83       	st	Y, r24
		if(ubRequest != CMD_SEND_BOOT)
    72d8:	98 38       	cpi	r25, 0x88	; 136
    72da:	81 f4       	brne	.+32     	; 0x72fc <main+0x98>
			break;
		// Read page from Ami
		if(!bootReadPageFromAmi())
    72dc:	0e 94 88 38 	call	0x7110	; 0x7110 <bootReadPageFromAmi>
    72e0:	88 23       	and	r24, r24
    72e2:	59 f3       	breq	.-42     	; 0x72ba <main+0x56>
			continue;

		// Program page on flash & wait for Ami read
		bootFlashPage();
    72e4:	0e 94 dd 38 	call	0x71ba	; 0x71ba <bootFlashPage>

		// Let Ami know that bootloader is ready for more
		PAR_STATUS_PORT |= NACK;
    72e8:	88 81       	ld	r24, Y
    72ea:	82 60       	ori	r24, 0x02	; 2
    72ec:	88 83       	st	Y, r24
    72ee:	c7 01       	movw	r24, r14
    72f0:	01 97       	sbiw	r24, 0x01	; 1
    72f2:	f1 f7       	brne	.-4      	; 0x72f0 <main+0x8c>
		_delay_ms(2);
		PAR_STATUS_PORT &= ~NACK;
    72f4:	88 81       	ld	r24, Y
    72f6:	8d 7f       	andi	r24, 0xFD	; 253
    72f8:	88 83       	st	Y, r24
    72fa:	df cf       	rjmp	.-66     	; 0x72ba <main+0x56>
	}
	bootExit();
    72fc:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <bootExit>
	return 0;
}
    7300:	80 e0       	ldi	r24, 0x00	; 0
    7302:	90 e0       	ldi	r25, 0x00	; 0
    7304:	df 91       	pop	r29
    7306:	cf 91       	pop	r28
    7308:	1f 91       	pop	r17
    730a:	0f 91       	pop	r16
    730c:	ff 90       	pop	r15
    730e:	ef 90       	pop	r14
    7310:	08 95       	ret

00007312 <_exit>:
    7312:	f8 94       	cli

00007314 <__stop_program>:
    7314:	ff cf       	rjmp	.-2      	; 0x7314 <__stop_program>
